# 基本文件操作

IO（Input/Output）是指程序与外部设备或文件进行交互的过程。它允许程序读取输入数据或向外输出结果。

## 常用方法：

- **`open()`**: 用于打开文件并返回文件对象。用途是访问文件，以进行读写操作。常见场景：需要读取或修改文件时使用。
    
- **`read()`**: 从文件中读取内容。用途是获取文件数据。常见场景：读取配置文件、日志文件等。
    
- **`write()`**: 向文件中写入内容。用途是保存或更新数据。常见场景：记录日志、输出计算结果等。
    
- **`close()`**: 关闭文件。用途是释放系统资源。常见场景：手动管理文件时，操作完成后关闭文件。
    
- **`seek()`**: 将文件指针移动到指定位置。用途是随机访问文件内容。常见场景：需要在文件中跳转读取时使用。
    
- **`tell()`**: 返回文件指针的当前位置。用途是获取当前读取位置，便于后续操作。常见场景：复杂的文件读写操作时使用。
    

## 文件模式：

- **`'r'`**: 只读模式，默认模式。适用于读取现有文件。
- **`‘w’``: 写入模式，会覆盖已有文件内容。适合新建文件或覆盖旧文件。
- **`'a'`**: 追加模式，在文件末尾添加新内容。适用于日志记录等需要持续追加的场景。
- **`'x'`**: 创建新文件，只写入模式。如果文件已存在，会抛出异常。
- **`'b'`**: 二进制模式，处理二进制文件如图片、音频等。
- **`'t'`**: 文本模式，默认模式，处理文本文件。
- **`'+'`**: 更新模式，允许同时读写文件。

## 使用场景：

- **读取文件**: 当需要获取文件内容时，使用`open()`和`read()`方法。
- **写入文件**: 当需要保存数据到文件时，使用`open()`和`write()`方法。
- **日志记录**: 使用`'a'`模式向文件追加日志信息。
- **处理二进制文件**: 在`open()`时添加`'b'`模式，使用`read()`和`write()`处理二进制数据。
- **随机访问**: 使用`seek()`和`tell()`实现文件内容的随机读写。

## 代码示例

```python
# 示例1：读取文件内容
with open('examplce.txt', 'r') as file:
    content = file.read()
    print(content)

# 示例2：写入新文件
new_content = "Hello, World!"
with open('new_file.txt', 'w') as file:
    file.write(new_content)

# 示例3：追加内容到文件
append_content = "\nAppended line."
with open('example.txt', 'a') as file:
    file.write(append_content)

# 示例4：处理二进制文件
with open('image.jpg', 'rb') as file:
    binary_data = file.read()
```

# OS模块删除文件和文件夹

### 1.1 删除文件 - `os.remove()`

- **解释**: 删除指定路径的一个文件。
- **用途**: 用于清理不需要的文件，例如临时文件或旧数据。
- **场景**:
    - 清理临时文件。
    - 更新数据后删除旧文件。

### 1.2 删除目录 - `os.rmdir()`

- **解释**: 删除指定路径的一个空目录。
- **用途**: 用于清理空的目录结构。
- **场景**:
    - 清理项目中的空文件夹。
    - 自动化组织文件夹结构。

### 1.3 删除目录及其内容 - `shutil.rmtree()`

- **解释**: 删除指定路径的目录及其所有子目录和文件。
- **用途**: 用于彻底移除整个目录树。
- **场景**:
    - 卸载软件时删除安装目录。
    - 执行完整的数据清理任务。

## 2. 演示代码示例

```python
import os
import shutil

# 删除文件
try:
    os.remove("example.txt")
except FileNotFoundError:
    print("文件 example.txt 不存在")

# 删除空目录
try:
    os.rmdir("empty_folder")
except OSError:
    print("目录 empty_folder 不为空或不存在")

# 删除目录及其内容
try:
    shutil.rmtree("test_directory")
except FileNotFoundError:
    print("目录 test_directory 不存在")
```

# Input

## 1. 简明解释

### 1.1 基本概念

- **解释**: 用户通过键盘输入数据，程序接收并处理这些输入。
- **用途**: 与用户交互，获取所需数据以执行特定功能。
- **场景**: 命令行工具、交互式程序、Web表单等。

### 1.2 `input()` 函数

- **解释**: 获取用户输入的一行文本，返回一个**字符串**。
- **用途**: 接收用户提供的信息，如名称、选项、数据等。
- **场景**: 登录界面、数据输入表单、交互式脚本。

## 2. 演示代码示例

```python
# 基础示例：获取用户名并问候
username = input("请输入您的名字：")
print(f"您好，{username}！")

# 示例：获取年龄并进行判断
age = int(input("请输入您的年龄："))
if age >= 18:
    print("您已成年。")
else:
    print("您还未成年。")

# 示例：循环获取多个输入
fruits = []
while True:
    fruit = input("请输入您喜欢的水果（'exit' 退出）：").strip().lower()
    if fruit == 'exit':
        break
    fruits.append(fruit)
print("您喜欢的水果有：", fruits)
```

## 3. 初学者常见错误及解决方法

1. **错误**：未对输入数据进行验证。
    
    - **解决**：添加输入验证逻辑，确保输入符合预期格式和范围。
2. **错误**：直接将输入转换为特定类型而不处理异常。
    
    - **解决**：使用 try-except 块捕获转换异常，提示用户重新输入。
3. **错误**：未考虑输入中的额外空白字符。
    
    - **解决**：使用 `strip()` 方法去除首尾空格，或进行更严格的字符串处理。

# 序列化和反序列化

- **解释**：序列化是将对象转换为可以存储或传输的格式（如字节序列、JSON 字符串等）的过程；反序列化则是将序列化后的数据重新转换为对象的过程。

- **用途**：主要用于数据的持久化存储、网络传输等。

- **常见使用场景**：
    - 数据存储：将对象保存到文件或数据库中。
    - 网络通信：在不同的进程或计算机之间传输对象。

### 简单代码示例

```python
import json

# 定义一个简单的Python对象
person = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

# 序列化：将Python对象转换为JSON字符串
serialized_data = json.dumps(person)
print(f"Serialized data: {serialized_data}")

# 反序列化：将JSON字符串转换为Python对象
deserialized_data = json.loads(serialized_data)
print(f"Deserialized data: {deserialized_data}")
```

###  初学者常见的三个错误或误解及避免方法

- **错误 1：忘记序列化和反序列化使用相同的格式**
    - **解释**：例如，使用 JSON 序列化数据，但尝试使用 Pickle 进行反序列化，会导致错误。
    - **避免方法**：确保在序列化和反序列化时使用相同的库和格式。
- **错误 2：对不可序列化的对象进行序列化**
    - **解释**：有些对象（如自定义类的实例，且没有实现特定的序列化方法）不能直接序列化。
    - **避免方法**：对于自定义类，实现`__dict__`方法或使用`__getstate__`和`__setstate__`方法来定义序列化和反序列化的行为。
- **错误 3：忽略序列化数据的安全性**
    - **解释**：在反序列化不受信任的数据时，可能会执行恶意代码（如 Pickle）。
    - **避免方法**：尽量使用安全的序列化格式（如 JSON），避免反序列化不受信任的数据。